<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Android," />










<meta name="description" content="0x00 前言 早期的一种Android加固手段是通过动态地加载dex文件来达到保护目的，当然这种办法早就已经过时，那么要了解这种加固手段就必须了解Android的动态加载机制">
<meta name="keywords" content="Android">
<meta property="og:type" content="article">
<meta property="og:title" content="Dalvik加载dex">
<meta property="og:url" content="http://yoursite.com/2018/03/17/Dalvik加载dex/index.html">
<meta property="og:site_name" content="Mask&#39;s Blog">
<meta property="og:description" content="0x00 前言 早期的一种Android加固手段是通过动态地加载dex文件来达到保护目的，当然这种办法早就已经过时，那么要了解这种加固手段就必须了解Android的动态加载机制">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://yoursite.com/2018/03/17/Dalvik加载dex/0.png">
<meta property="og:image" content="http://yoursite.com/2018/03/17/Dalvik加载dex/1.png">
<meta property="og:image" content="http://yoursite.com/2018/03/17/Dalvik加载dex/2.png">
<meta property="og:image" content="http://yoursite.com/2018/03/17/Dalvik加载dex/3.png">
<meta property="og:image" content="http://yoursite.com/2018/03/17/Dalvik加载dex/4.png">
<meta property="og:image" content="http://yoursite.com/2018/03/17/Dalvik加载dex/5.png">
<meta property="og:image" content="http://yoursite.com/2018/03/17/Dalvik加载dex/6.png">
<meta property="og:image" content="http://yoursite.com/2018/03/17/Dalvik加载dex/7.png">
<meta property="og:image" content="http://yoursite.com/2018/03/17/Dalvik加载dex/9.png">
<meta property="og:updated_time" content="2018-04-08T12:20:41.765Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Dalvik加载dex">
<meta name="twitter:description" content="0x00 前言 早期的一种Android加固手段是通过动态地加载dex文件来达到保护目的，当然这种办法早就已经过时，那么要了解这种加固手段就必须了解Android的动态加载机制">
<meta name="twitter:image" content="http://yoursite.com/2018/03/17/Dalvik加载dex/0.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/03/17/Dalvik加载dex/"/>





  <title>Dalvik加载dex | Mask's Blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Mask's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/About/" rel="section">
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-嘤嘤嘤">
          <a href="/嘤嘤嘤嘤" rel="section">
            
            嘤嘤嘤
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/17/Dalvik加载dex/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mask">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mask's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Dalvik加载dex</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-17T19:30:24+08:00">
                2018-03-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><blockquote>
<p>早期的一种Android加固手段是通过动态地加载dex文件来达到保护目的，当然这种办法早就已经过时，那么要了解这种加固手段就必须了解Android的动态加载机制</p>
</blockquote>
<a id="more"></a>
<h2 id="0x01-DexClassLoader和PathClassLoader"><a href="#0x01-DexClassLoader和PathClassLoader" class="headerlink" title="0x01 DexClassLoader和PathClassLoader"></a>0x01 DexClassLoader和PathClassLoader</h2><p>Android中有许多类加载器，当然本文讨论范围主要是<code>DexClassLoader</code>和<code>PathClassLoader</code>这两个，这两个类都继承自<code>BaseDexCloader</code>这个父类，区别在于PathClassLoader这个类默认的优化路径参数为null，所以只能是内部存储路径，而DexClassLoader则可以选择内部存储路径或者外部存储路径</p>
<p>PathClassLoader:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class PathClassLoader extends BaseDexClassLoader &#123;</span><br><span class="line">	public PathClassLoader(String dexPath, ClassLoader parent) &#123;</span><br><span class="line">		super(dexPath, null, null, parent);</span><br><span class="line">	&#125;</span><br><span class="line">	public PathClassLoader(String dexPath, String libraryPath,</span><br><span class="line">ClassLoader parent) &#123;</span><br><span class="line">		super(dexPath, null, libraryPath, parent);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DexClassLoader:<br>​    </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class DexClassLoader extends BaseDexClassLoader &#123;</span><br><span class="line">	public DexClassLoader(String dexPath, String optimizedDirectory,</span><br><span class="line">	String libraryPath, ClassLoader parent) &#123;</span><br><span class="line">	super(dexPath, new File(optimizedDirectory), libraryPath, parent);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发现他们均是调用父类的构造函数，跟进查看：<br>​    </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public BaseDexClassLoader(String dexPath, File optimizedDirectory,</span><br><span class="line">String libraryPath, ClassLoader parent) &#123;</span><br><span class="line">	super(parent);</span><br><span class="line">	this.pathList = new DexPathList(this, dexPath, libraryPath, optimizedDirectory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二个参数<code>optimizedDirectory</code>就是dex文件优化后的输出路径，可以看到<code>DexClassLoader</code>中使用了<code>new File()</code>函数来指定相应的路径，而<code>PathClassLoader</code>则是传入了<code>null</code>值，那么只能是默认的内部存储</p>
<p>这两个类差距就在这，其他的区别不大，都是调用父类的构造函数</p>
<h2 id="0x02-Davlik加载Dex文件"><a href="#0x02-Davlik加载Dex文件" class="headerlink" title="0x02 Davlik加载Dex文件"></a>0x02 Davlik加载Dex文件</h2><blockquote>
<p>应用程序在第一次启动app的时候，会在/dalvik/dalvik-cache目录下生成odex文件结构，其实就是在原app的dex文件结构基础上，增加odex文件头和并在原dex文件末尾增加依赖库信息和辅助信息，依赖库信息知名该dex文件所需要的本地函数库。</p>
<p>辅助信息记录了dex中类的索引表，dalvik为每一个dex文件创建一个对应DexClassLookup对象用于记dex文件所有的类索引信息，DexClassLookup对象为的每个类都生成了table结构体对象，该对象记录了类的描述符的哈希值、类描述符在dex文件中的偏移和类在dex文件中的偏移。其table结构体对象定义如下。也就是说通过该table结构体对象就可以对dex文件中某一个类快速定位。</p>
</blockquote>
<img src="/2018/03/17/Dalvik加载dex/0.png">
<p>Davlik加载解析dex的过程中有几个重要的数据结构<code>DexFile</code>,<code>RawDexFile</code>,<code>DvmDex</code>和<code>ClassObject</code>,加载的dex解析之后就是以ClassObject的形式存储在内存中，然后通过解析具体的指令集去执行。存储指令集的数据结构就是Method结构体中的insns数组，这个了解过Dex文件结构的应该清楚。ClassObject结构体对象几乎包含类目标在运行时所需的所有资源，包括当前类的超类、当前类使用的类加载器、Method类型指针等。</p>
<img src="/2018/03/17/Dalvik加载dex/1.png">
<p>app在启动过程中创建了PathClassLoader去加载dex文件：<br>源码位置：<a href="http://androidxref.com/4.4_r1/xref/frameworks/base/core/java/android/app/ApplicationLoaders.java" target="_blank" rel="noopener">http://androidxref.com/4.4_r1/xref/frameworks/base/core/java/android/app/ApplicationLoaders.java</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">class ApplicationLoaders</span><br><span class="line">&#123;</span><br><span class="line">public static ApplicationLoaders getDefault()</span><br><span class="line">&#123;</span><br><span class="line">    return gApplicationLoaders;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public ClassLoader getClassLoader(String zip, String libPath, ClassLoader parent)</span><br><span class="line">&#123;</span><br><span class="line">    /*</span><br><span class="line">     * This is the parent we use if they pass &quot;null&quot; in.  In theory</span><br><span class="line">     * this should be the &quot;system&quot; class loader; in practice we</span><br><span class="line">     * don&apos;t use that and can happily (and more efficiently) use the</span><br><span class="line">     * bootstrap class loader.</span><br><span class="line">     */</span><br><span class="line">    ClassLoader baseParent = ClassLoader.getSystemClassLoader().getParent();</span><br><span class="line"></span><br><span class="line">    synchronized (mLoaders) &#123;</span><br><span class="line">        if (parent == null) &#123;</span><br><span class="line">            parent = baseParent;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">         * If we&apos;re one step up from the base class loader, find</span><br><span class="line">         * something in our cache.  Otherwise, we create a whole</span><br><span class="line">         * new ClassLoader for the zip archive.</span><br><span class="line">         */</span><br><span class="line">        if (parent == baseParent) &#123;</span><br><span class="line">            ClassLoader loader = mLoaders.get(zip);</span><br><span class="line">            if (loader != null) &#123;</span><br><span class="line">                return loader;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, zip);</span><br><span class="line">            PathClassLoader pathClassloader =</span><br><span class="line">                new PathClassLoader(zip, libPath, parent);</span><br><span class="line">            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line"></span><br><span class="line">            mLoaders.put(zip, pathClassloader);</span><br><span class="line">            return pathClassloader;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, zip);</span><br><span class="line">        PathClassLoader pathClassloader = new PathClassLoader(zip, parent);</span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">        return pathClassloader;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private final ArrayMap&lt;String, ClassLoader&gt; mLoaders = new ArrayMap&lt;String, ClassLoader&gt;();</span><br><span class="line"></span><br><span class="line">private static final ApplicationLoaders gApplicationLoaders</span><br><span class="line">    = new ApplicationLoaders();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>跟进PathClassLoader个构造函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public PathClassLoader(String dexPath, ClassLoader parent) &#123;</span><br><span class="line">    super(dexPath, null, null, parent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>跟进父类BaseDexClassLoader:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Constructs an instance.</span><br><span class="line"> *</span><br><span class="line"> * @param dexPath the list of jar/apk files containing classes and</span><br><span class="line"> * resources, delimited by &#123;@code File.pathSeparator&#125;, which</span><br><span class="line"> * defaults to &#123;@code &quot;:&quot;&#125; on Android</span><br><span class="line"> * @param optimizedDirectory directory where optimized dex files</span><br><span class="line"> * should be written; may be &#123;@code null&#125;</span><br><span class="line"> * @param libraryPath the list of directories containing native</span><br><span class="line"> * libraries, delimited by &#123;@code File.pathSeparator&#125;; may be</span><br><span class="line"> * &#123;@code null&#125;</span><br><span class="line"> * @param parent the parent class loader</span><br><span class="line"> */</span><br><span class="line">public BaseDexClassLoader(String dexPath, File optimizedDirectory,</span><br><span class="line">        String libraryPath, ClassLoader parent) &#123;</span><br><span class="line">    super(parent);</span><br><span class="line">    this.pathList = new DexPathList(this, dexPath, libraryPath, optimizedDirectory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里有四个参数：</p>
<ul>
<li>dexPath————————–dex的路径</li>
<li>optimizedDirectory ————优化后的存储路径</li>
<li>libraryPath———————–包含native方法的库文件路径</li>
<li>parent—————————-父加载器</li>
</ul>
<p>调用了父类ClassLoader构造函数，这里重点关注这个DexPathList函数，跟进查看其构造函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public DexPathList(ClassLoader definingContext, String dexPath,</span><br><span class="line">        String libraryPath, File optimizedDirectory) &#123;</span><br><span class="line">    if (definingContext == null) &#123;</span><br><span class="line">        throw new NullPointerException(&quot;definingContext == null&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (dexPath == null) &#123;</span><br><span class="line">        throw new NullPointerException(&quot;dexPath == null&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (optimizedDirectory != null) &#123;</span><br><span class="line">        if (!optimizedDirectory.exists())  &#123;</span><br><span class="line">            throw new IllegalArgumentException(</span><br><span class="line">                    &quot;optimizedDirectory doesn&apos;t exist: &quot;</span><br><span class="line">                    + optimizedDirectory);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (!(optimizedDirectory.canRead()</span><br><span class="line">                        &amp;&amp; optimizedDirectory.canWrite())) &#123;</span><br><span class="line">            throw new IllegalArgumentException(</span><br><span class="line">                    &quot;optimizedDirectory not readable/writable: &quot;</span><br><span class="line">                    + optimizedDirectory);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //上面各种验证</span><br><span class="line">    this.definingContext = definingContext;</span><br><span class="line">    ArrayList&lt;IOException&gt; suppressedExceptions = new ArrayList&lt;IOException&gt;();</span><br><span class="line">    this.dexElements = makeDexElements(splitDexPath(dexPath), optimizedDirectory,</span><br><span class="line">                                       suppressedExceptions);</span><br><span class="line">    if (suppressedExceptions.size() &gt; 0) &#123;</span><br><span class="line">        this.dexElementsSuppressedExceptions =</span><br><span class="line">            suppressedExceptions.toArray(new IOException[suppressedExceptions.size()]);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        dexElementsSuppressedExceptions = null;</span><br><span class="line">    &#125;</span><br><span class="line">    this.nativeLibraryDirectories = splitLibraryPath(libraryPath);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前面巴拉巴拉的一大堆验证，先不管，跟进此处这个重要的函数<code>makeDexElements(splitDexPath(dexPath), optimizedDirectory,suppressedExceptions);</code></p>
<p>这个splitDexPath函数作用是将传进来的dexPath路径进行字符串分割</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Splits the given path strings into file elements using the path</span><br><span class="line"> * separator, combining the results and filtering out elements</span><br><span class="line"> * that don&apos;t exist, aren&apos;t readable, or aren&apos;t either a regular</span><br><span class="line"> * file or a directory (as specified). Either string may be empty</span><br><span class="line"> * or &#123;@code null&#125;, in which case it is ignored. If both strings</span><br><span class="line"> * are empty or &#123;@code null&#125;, or all elements get pruned out, then</span><br><span class="line"> * this returns a zero-element list.</span><br><span class="line"> */</span><br><span class="line">private static ArrayList&lt;File&gt; splitPaths(String path1, String path2,</span><br><span class="line">        boolean wantDirectories) &#123;</span><br><span class="line">    ArrayList&lt;File&gt; result = new ArrayList&lt;File&gt;();</span><br><span class="line"></span><br><span class="line">    splitAndAdd(path1, wantDirectories, result);</span><br><span class="line">    splitAndAdd(path2, wantDirectories, result);</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Helper for &#123;@link #splitPaths&#125;, which does the actual splitting</span><br><span class="line"> * and filtering and adding to a result.</span><br><span class="line"> */</span><br><span class="line">private static void splitAndAdd(String searchPath, boolean directoriesOnly,</span><br><span class="line">        ArrayList&lt;File&gt; resultList) &#123;</span><br><span class="line">    if (searchPath == null) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    for (String path : searchPath.split(&quot;:&quot;)) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            StructStat sb = Libcore.os.stat(path);</span><br><span class="line">            if (!directoriesOnly || S_ISDIR(sb.st_mode)) &#123;</span><br><span class="line">                resultList.add(new File(path));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (ErrnoException ignored) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将分割后的字符串传递给<code>makeDexElements</code>函数</p>
<img src="/2018/03/17/Dalvik加载dex/2.png">
<p>发现无论是dex结尾的还是jar,apk结尾的都会去调用loadDexFile函数，然后返回一个Dexfile类型</p>
<p><code>dex = loadDexFile(file, optimizedDirectory);</code></p>
<p>那么跟进查看</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Constructs a &#123;@code DexFile&#125; instance, as appropriate depending</span><br><span class="line"> * on whether &#123;@code optimizedDirectory&#125; is &#123;@code null&#125;.</span><br><span class="line"> */</span><br><span class="line">private static DexFile loadDexFile(File file, File optimizedDirectory)</span><br><span class="line">        throws IOException &#123;</span><br><span class="line">    if (optimizedDirectory == null) &#123;</span><br><span class="line">        return new DexFile(file);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        String optimizedPath = optimizedPathFor(file, optimizedDirectory);</span><br><span class="line">        return DexFile.loadDex(file.getPath(), optimizedPath, 0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里会先判断传递进来的optimizedDirectory是否为空，那么因为之前是由PathClassLoader传递进来的，那么这个变量肯定就是null了，那么我们就跟进DexFile的构造函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Opens a DEX file from a given File object. This will usually be a ZIP/JAR</span><br><span class="line"> * file with a &quot;classes.dex&quot; inside.</span><br><span class="line"> *</span><br><span class="line"> * The VM will generate the name of the corresponding file in</span><br><span class="line"> * /data/dalvik-cache and open it, possibly creating or updating</span><br><span class="line"> * it first if system permissions allow.  Don&apos;t pass in the name of</span><br><span class="line"> * a file in /data/dalvik-cache, as the named file is expected to be</span><br><span class="line"> * in its original (pre-dexopt) state.</span><br><span class="line"> *</span><br><span class="line"> * @param file</span><br><span class="line"> *            the File object referencing the actual DEX file</span><br><span class="line"> *</span><br><span class="line"> * @throws IOException</span><br><span class="line"> *             if an I/O error occurs, such as the file not being found or</span><br><span class="line"> *             access rights missing for opening it</span><br><span class="line"> */</span><br><span class="line">public DexFile(File file) throws IOException &#123;</span><br><span class="line">    this(file.getPath());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注释写的很清楚，继续跟进：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Opens a DEX file from a given filename. This will usually be a ZIP/JAR</span><br><span class="line"> * file with a &quot;classes.dex&quot; inside.</span><br><span class="line"> *</span><br><span class="line"> * The VM will generate the name of the corresponding file in</span><br><span class="line"> * /data/dalvik-cache and open it, possibly creating or updating</span><br><span class="line"> * it first if system permissions allow.  Don&apos;t pass in the name of</span><br><span class="line"> * a file in /data/dalvik-cache, as the named file is expected to be</span><br><span class="line"> * in its original (pre-dexopt) state.</span><br><span class="line"> *</span><br><span class="line"> * @param fileName</span><br><span class="line"> *            the filename of the DEX file</span><br><span class="line"> *</span><br><span class="line"> * @throws IOException</span><br><span class="line"> *             if an I/O error occurs, such as the file not being found or</span><br><span class="line"> *             access rights missing for opening it</span><br><span class="line"> */</span><br><span class="line">public DexFile(String fileName) throws IOException &#123;</span><br><span class="line">    mCookie = openDexFile(fileName, null, 0);</span><br><span class="line">    mFileName = fileName;</span><br><span class="line">    guard.open(&quot;close&quot;);</span><br><span class="line">    //System.out.println(&quot;DEX FILE cookie is &quot; + mCookie);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里调用了一个openDexFile()，其实不管你传进来的optimizedDirectory是否为空，最后都会调用到这个函数</p>
<p>调用完后会返回一个Cookie记录，那么我们跟进这个函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Open a DEX file.  The value returned is a magic VM cookie.  On</span><br><span class="line"> * failure, an IOException is thrown.</span><br><span class="line"> */</span><br><span class="line">private static int openDexFile(String sourceName, String outputName,</span><br><span class="line">    int flags) throws IOException &#123;</span><br><span class="line">    return openDexFileNative(new File(sourceName).getCanonicalPath(),</span><br><span class="line">                             (outputName == null) ? null : new File(outputName).getCanonicalPath(),</span><br><span class="line">                             flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">native private static int openDexFileNative(String sourceName, String outputName,</span><br><span class="line">    int flags) throws IOException;</span><br></pre></td></tr></table></figure>
<p>发现最终会调用一个native函数，继续跟进</p>
<p><a href="http://androidxref.com/4.4_r1/xref/dalvik/vm/native/dalvik_system_DexFile.cpp" target="_blank" rel="noopener">http://androidxref.com/4.4_r1/xref/dalvik/vm/native/dalvik_system_DexFile.cpp</a></p>
<img src="/2018/03/17/Dalvik加载dex/3.png">
<p>下面有几个判断，一个一个来：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if (hasDexExtension(sourceName)</span><br><span class="line">        &amp;&amp; dvmRawDexFileOpen(sourceName, outputName, &amp;pRawDexFile, false) == 0) &#123;</span><br><span class="line">    ALOGV(&quot;Opening DEX file &apos;%s&apos; (DEX)&quot;, sourceName);</span><br><span class="line"></span><br><span class="line">    pDexOrJar = (DexOrJar*) malloc(sizeof(DexOrJar));</span><br><span class="line">    pDexOrJar-&gt;isDex = true;</span><br><span class="line">    pDexOrJar-&gt;pRawDexFile = pRawDexFile;</span><br><span class="line">    pDexOrJar-&gt;pDexMemory = NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>hasDexExtension</code>判断是否以dex结尾，如果是，继续<code>dvmRawDexFileOpen()</code>操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">else if (dvmJarFileOpen(sourceName, outputName, &amp;pJarFile, false) == 0) &#123;</span><br><span class="line">    ALOGV(&quot;Opening DEX file &apos;%s&apos; (Jar)&quot;, sourceName);</span><br><span class="line"></span><br><span class="line">    pDexOrJar = (DexOrJar*) malloc(sizeof(DexOrJar));</span><br><span class="line">    pDexOrJar-&gt;isDex = false;</span><br><span class="line">    pDexOrJar-&gt;pJarFile = pJarFile;</span><br><span class="line">    pDexOrJar-&gt;pDexMemory = NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>apk或者jar结尾的就进行<code>dvmJarFileOpen</code>操作</p>
<p>那么这个native函数主要也就是进行这两个操作，其实两个函数操作差不多，只是第二个多了一个提取，将dex文件提取出来。</p>
<p>跟进第一个函数，有点长，一段一段来：</p>
<img src="/2018/03/17/Dalvik加载dex/4.png">
<p>然后往下跟进：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> /*</span><br><span class="line"> * See if the cached file matches. If so, optFd will become a reference</span><br><span class="line"> * to the cached file and will have been seeked to just past the &quot;opt&quot;</span><br><span class="line"> * header.</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">if (odexOutputName == NULL) &#123;</span><br><span class="line">    cachedName = dexOptGenerateCacheFileName(fileName, NULL);</span><br><span class="line">    if (cachedName == NULL)</span><br><span class="line">        goto bail;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    cachedName = strdup(odexOutputName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里cachedName是就是新建的一个缓存，那么这里只要先在这个缓存操作，然后再把缓存拷贝到目标文件即可，注意这个strdup函数，这是个拷贝函数内部会调用malloc创建内存，后面有free函数跟他相匹配出现</p>
<p>继续跟进</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">optFd = dvmOpenCachedDexFile(fileName, cachedName, modTime,</span><br><span class="line">adler32, isBootstrap, &amp;newFile, /*createIfMissing=*/true);</span><br></pre></td></tr></table></figure>
<p>这个函数的作用就是给dex文件写入一个opt头，如果写成功那么newFile的值变为true</p>
<p>具体就不跟进，主要操作如下：</p>
<img src="/2018/03/17/Dalvik加载dex/5.png">
<p>如果写入成功：</p>
<img src="/2018/03/17/Dalvik加载dex/6.png">
<p>再往下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (dvmDexFileOpenFromFd(optFd, &amp;pDvmDex) != 0) &#123;</span><br><span class="line">    ALOGI(&quot;Unable to map cached %s&quot;, fileName);</span><br><span class="line">    goto bail;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>dvmDexFileOpenFromFd</code>这个函数最主要就是，将优化后得dex文件（也就是odex文件）通过<code>mmap</code>映射到内存中，并通过<code>mprotect</code>修改它的映射内存为只读权限，然后将映射为只读的这块dex数据中的内容全部提取到<code>DexFile</code>这个数据结构中去</p>
<p>然后最后成功的话就返回给RawDexFile</p>
<p>然后回到这：</p>
<img src="/2018/03/17/Dalvik加载dex/7.png">
<p>那么dvmJarFileOpen函数的操作大同小异，就是多了一个提取的操作</p>
<p>最后将这个返回给之前的Cookie</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RETURN_PTR(pDexOrJar);</span><br></pre></td></tr></table></figure>
<p>看一下宏定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define RETURN_PTR(_val)do &#123; pResult-&gt;l = (Object*)(_val); return; &#125; while(0)</span><br></pre></td></tr></table></figure>
<p>那么所谓cookie其实是个DexOrJar类型结构体的指针</p>
<p>那么整个加载的流程差不多就是这样了。。。。。。</p>
<h2 id="0x03-运行时解析"><a href="#0x03-运行时解析" class="headerlink" title="0x03 运行时解析"></a>0x03 运行时解析</h2><p>类加载的目的其实就是为所需的类生成一个ClassObject的实例，然后需要的时候调用这个实例对象</p>
<p>看一下ClassObject的定义，里面有一些描述变量以及一些辅助的描述信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Class objects have many additional fields.  This is used for both</span><br><span class="line"> * classes and interfaces, including synthesized classes (arrays and</span><br><span class="line"> * primitive types).</span><br><span class="line"> *</span><br><span class="line"> * Class objects are unusual in that they have some fields allocated with</span><br><span class="line"> * the system malloc (or LinearAlloc), rather than on the GC heap.  This is</span><br><span class="line"> * handy during initialization, but does require special handling when</span><br><span class="line"> * discarding java.lang.Class objects.</span><br><span class="line"> *</span><br><span class="line"> * The separation of methods (direct vs. virtual) and fields (class vs.</span><br><span class="line"> * instance) used in Dalvik works out pretty well.  The only time it&apos;s</span><br><span class="line"> * annoying is when enumerating or searching for things with reflection.</span><br><span class="line"> */</span><br><span class="line">struct ClassObject : Object &#123;</span><br><span class="line">    /* leave space for instance data; we could access fields directly if we</span><br><span class="line">       freeze the definition of java/lang/Class */</span><br><span class="line">    u4              instanceData[CLASS_FIELD_SLOTS];</span><br><span class="line"></span><br><span class="line">    /* UTF-8 descriptor for the class; from constant pool, or on heap</span><br><span class="line">       if generated (&quot;[C&quot;) */</span><br><span class="line">    const char*     descriptor;</span><br><span class="line">    char*           descriptorAlloc;</span><br><span class="line"></span><br><span class="line">    /* access flags; low 16 bits are defined by VM spec */</span><br><span class="line">    u4              accessFlags;</span><br><span class="line"></span><br><span class="line">    /* VM-unique class serial number, nonzero, set very early */</span><br><span class="line">    u4              serialNumber;</span><br><span class="line"></span><br><span class="line">    /* DexFile from which we came; needed to resolve constant pool entries */</span><br><span class="line">    /* (will be NULL for VM-generated, e.g. arrays and primitive classes) */</span><br><span class="line">    DvmDex*         pDvmDex;</span><br><span class="line"></span><br><span class="line">    /* state of class initialization */</span><br><span class="line">    ClassStatus     status;</span><br><span class="line"></span><br><span class="line">    /* if class verify fails, we must return same error on subsequent tries */</span><br><span class="line">    ClassObject*    verifyErrorClass;</span><br><span class="line"></span><br><span class="line">    /* threadId, used to check for recursive &lt;clinit&gt; invocation */</span><br><span class="line">    u4              initThreadId;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * Total object size; used when allocating storage on gc heap.  (For</span><br><span class="line">     * interfaces and abstract classes this will be zero.)</span><br><span class="line">     */</span><br><span class="line">    size_t          objectSize;</span><br><span class="line"></span><br><span class="line">    /* arrays only: class object for base element, for instanceof/checkcast</span><br><span class="line">       (for String[][][], this will be String) */</span><br><span class="line">    ClassObject*    elementClass;</span><br><span class="line"></span><br><span class="line">    /* arrays only: number of dimensions, e.g. int[][] is 2 */</span><br><span class="line">    int             arrayDim;</span><br><span class="line"></span><br><span class="line">    /* primitive type index, or PRIM_NOT (-1); set for generated prim classes */</span><br><span class="line">    PrimitiveType   primitiveType;</span><br><span class="line"></span><br><span class="line">    /* superclass, or NULL if this is java.lang.Object */</span><br><span class="line">    ClassObject*    super;</span><br><span class="line"></span><br><span class="line">    /* defining class loader, or NULL for the &quot;bootstrap&quot; system loader */</span><br><span class="line">    Object*         classLoader;</span><br><span class="line"></span><br><span class="line">    /* initiating class loader list */</span><br><span class="line">    /* NOTE: for classes with low serialNumber, these are unused, and the</span><br><span class="line">       values are kept in a table in gDvm. */</span><br><span class="line">    InitiatingLoaderList initiatingLoaderList;</span><br><span class="line"></span><br><span class="line">    /* array of interfaces this class implements directly */</span><br><span class="line">    int             interfaceCount;</span><br><span class="line">    ClassObject**   interfaces;</span><br><span class="line"></span><br><span class="line">    /* static, private, and &lt;init&gt; methods */</span><br><span class="line">    int             directMethodCount;</span><br><span class="line">    Method*         directMethods;</span><br><span class="line"></span><br><span class="line">    /* virtual methods defined in this class; invoked through vtable */</span><br><span class="line">    int             virtualMethodCount;</span><br><span class="line">    Method*         virtualMethods;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * Virtual method table (vtable), for use by &quot;invoke-virtual&quot;.  The</span><br><span class="line">     * vtable from the superclass is copied in, and virtual methods from</span><br><span class="line">     * our class either replace those from the super or are appended.</span><br><span class="line">     */</span><br><span class="line">    int             vtableCount;</span><br><span class="line">    Method**        vtable;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * Interface table (iftable), one entry per interface supported by</span><br><span class="line">     * this class.  That means one entry for each interface we support</span><br><span class="line">     * directly, indirectly via superclass, or indirectly via</span><br><span class="line">     * superinterface.  This will be null if neither we nor our superclass</span><br><span class="line">     * implement any interfaces.</span><br><span class="line">     *</span><br><span class="line">     * Why we need this: given &quot;class Foo implements Face&quot;, declare</span><br><span class="line">     * &quot;Face faceObj = new Foo()&quot;.  Invoke faceObj.blah(), where &quot;blah&quot; is</span><br><span class="line">     * part of the Face interface.  We can&apos;t easily use a single vtable.</span><br><span class="line">     *</span><br><span class="line">     * For every interface a concrete class implements, we create a list of</span><br><span class="line">     * virtualMethod indices for the methods in the interface.</span><br><span class="line">     */</span><br><span class="line">    int             iftableCount;</span><br><span class="line">    InterfaceEntry* iftable;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * The interface vtable indices for iftable get stored here.  By placing</span><br><span class="line">     * them all in a single pool for each class that implements interfaces,</span><br><span class="line">     * we decrease the number of allocations.</span><br><span class="line">     */</span><br><span class="line">    int             ifviPoolCount;</span><br><span class="line">    int*            ifviPool;</span><br><span class="line"></span><br><span class="line">    /* instance fields</span><br><span class="line">     *</span><br><span class="line">     * These describe the layout of the contents of a DataObject-compatible</span><br><span class="line">     * Object.  Note that only the fields directly defined by this class</span><br><span class="line">     * are listed in ifields;  fields defined by a superclass are listed</span><br><span class="line">     * in the superclass&apos;s ClassObject.ifields.</span><br><span class="line">     *</span><br><span class="line">     * All instance fields that refer to objects are guaranteed to be</span><br><span class="line">     * at the beginning of the field list.  ifieldRefCount specifies</span><br><span class="line">     * the number of reference fields.</span><br><span class="line">     */</span><br><span class="line">    int             ifieldCount;</span><br><span class="line">    int             ifieldRefCount; // number of fields that are object refs</span><br><span class="line">    InstField*      ifields;</span><br><span class="line"></span><br><span class="line">    /* bitmap of offsets of ifields */</span><br><span class="line">    u4 refOffsets;</span><br><span class="line"></span><br><span class="line">    /* source file name, if known */</span><br><span class="line">    const char*     sourceFile;</span><br><span class="line"></span><br><span class="line">    /* static fields */</span><br><span class="line">    int             sfieldCount;</span><br><span class="line">    StaticField     sfields[0]; /* MUST be last item */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>大致分析一下流程</p>
<p>回到BaseDexClassLoader.java</p>
<p>这里的findclass方法就是对指定的类名开始进行搜索加载，跟进查看，这里调用了DexPathList类的findclass方法</p>
<pre><code>/**
 * Finds the named class in one of the dex files pointed at by
 * this instance. This will find the one in the earliest listed
 * path element. If the class is found but has not yet been
 * defined, then this method will define it in the defining
 * context that this instance was constructed with.
 *
 * @param name of class to find
 * @param suppressed exceptions encountered whilst finding the class
 * @return the named class or {@code null} if the class is not
 * found in any of the dex files
 */
public Class findClass(String name, List&lt;Throwable&gt; suppressed) {
    for (Element element : dexElements) {
        DexFile dex = element.dexFile;

        if (dex != null) {
            Class clazz = dex.loadClassBinaryName(name, definingContext, suppressed);
            if (clazz != null) {
                return clazz;
            }
        }
    }
    if (dexElementsSuppressedExceptions != null) {
        suppressed.addAll(Arrays.asList(dexElementsSuppressedExceptions));
    }
    return null;
}
</code></pre><p>这里的dexElements，来看下定义 ，那么这里就是遍历一下之前所有的DexFile实例，其实也就是遍历了所有加载过的dex文件</p>
<pre><code> /**
 * List of dex/resource (class path) elements.
 * Should be called pathElements, but the Facebook app uses reflection
 * to modify &apos;dexElements&apos; (http://b/7726934).
 */
private final Element[] dexElements;
</code></pre><p>然后调用了loadClassBinaryName方法，跟过去看下</p>
<pre><code> /**
 * See {@link #loadClass(String, ClassLoader)}.
 *
 * This takes a &quot;binary&quot; class name to better match ClassLoader semantics.
 *
 * @hide
 */
public Class loadClassBinaryName(String name, ClassLoader loader, List&lt;Throwable&gt; suppressed) {
    return defineClass(name, loader, mCookie, suppressed);
}
</code></pre><p>调用了defineClass，跟进</p>
<pre><code>    private static Class defineClass(String name, ClassLoader loader, int cookie, List&lt;Throwable&gt; suppressed) {
    Class result = null;
    try {
        result = defineClassNative(name, loader, cookie);
    } catch (NoClassDefFoundError e) {
        if (suppressed != null) {
            suppressed.add(e);
        }
    } catch (ClassNotFoundException e) {
        if (suppressed != null) {
            suppressed.add(e);
        }
    }
    return result;
}
</code></pre><p>此处调用了一个native层的方法defineClassNative</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">private static native Class defineClassNative(String name, ClassLoader loader, int cookie)</span><br><span class="line">        throws ClassNotFoundException, NoClassDefFoundError;</span><br></pre></td></tr></table></figure>
<p>有点长，一段段来分析</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">static void Dalvik_dalvik_system_DexFile_defineClassNative(const u4* args,</span><br><span class="line">    JValue* pResult)</span><br><span class="line">&#123;</span><br><span class="line">    StringObject* nameObj = (StringObject*) args[0];</span><br><span class="line">    Object* loader = (Object*) args[1];</span><br><span class="line">    int cookie = args[2];</span><br><span class="line">    ClassObject* clazz = NULL;</span><br><span class="line">    DexOrJar* pDexOrJar = (DexOrJar*) cookie;</span><br><span class="line">    DvmDex* pDvmDex;</span><br><span class="line">    char* name;</span><br><span class="line">    char* descriptor;</span><br><span class="line"></span><br><span class="line">    name = dvmCreateCstrFromString(nameObj); //类型转换</span><br><span class="line">    descriptor = dvmDotToDescriptor(name);//得到描述符</span><br><span class="line">    ALOGV(&quot;--- Explicit class load &apos;%s&apos; l=%p c=0x%08x&quot;,</span><br><span class="line">        descriptor, loader, cookie);</span><br><span class="line">    free(name);</span><br><span class="line"></span><br><span class="line">    if (!validateCookie(cookie))//校验是不是有效的cookie</span><br><span class="line">        RETURN_VOID();</span><br><span class="line"></span><br><span class="line">    if (pDexOrJar-&gt;isDex)//判断是dex或者jar</span><br><span class="line">        pDvmDex = dvmGetRawDexFileDex(pDexOrJar-&gt;pRawDexFile);//这里拿到DvmDex结构体</span><br><span class="line">    else</span><br><span class="line">        pDvmDex = dvmGetJarFileDex(pDexOrJar-&gt;pJarFile);//同上</span><br><span class="line"></span><br><span class="line">    /* once we load something, we can&apos;t unmap the storage */</span><br><span class="line">    pDexOrJar-&gt;okayToFree = false;</span><br><span class="line"></span><br><span class="line">    clazz = dvmDefineClass(pDvmDex, descriptor, loader);</span><br><span class="line">    Thread* self = dvmThreadSelf();</span><br><span class="line">    if (dvmCheckException(self)) &#123;</span><br><span class="line">        /*</span><br><span class="line">         * If we threw a &quot;class not found&quot; exception, stifle it, since the</span><br><span class="line">         * contract in the higher method says we simply return null if</span><br><span class="line">         * the class is not found.</span><br><span class="line">         */</span><br><span class="line">        Object* excep = dvmGetException(self);</span><br><span class="line">        if (strcmp(excep-&gt;clazz-&gt;descriptor,</span><br><span class="line">                   &quot;Ljava/lang/ClassNotFoundException;&quot;) == 0 ||</span><br><span class="line">            strcmp(excep-&gt;clazz-&gt;descriptor,</span><br><span class="line">                   &quot;Ljava/lang/NoClassDefFoundError;&quot;) == 0)</span><br><span class="line">        &#123;</span><br><span class="line">            dvmClearException(self);</span><br><span class="line">        &#125;</span><br><span class="line">        clazz = NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    free(descriptor);</span><br><span class="line">    RETURN_PTR(clazz);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>跟进一下dvmDefineClass</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ClassObject* dvmDefineClass(DvmDex* pDvmDex, const char* descriptor,</span><br><span class="line">    Object* classLoader)</span><br><span class="line">&#123;</span><br><span class="line">    assert(pDvmDex != NULL);</span><br><span class="line"></span><br><span class="line">    return findClassNoInit(descriptor, classLoader, pDvmDex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里返回调用了findClassNoInit方法，跟过去看一下（此处参考文章<a href="http://pwn4.fun/2016/04/11/Dalvik%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%A8%A1%E5%9D%97/）" target="_blank" rel="noopener">http://pwn4.fun/2016/04/11/Dalvik%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%A8%A1%E5%9D%97/）</a></p>
<p>这函数有点长0.0，就取关键部分分析</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line">static ClassObject* findClassNoInit(const char* descriptor, Object* loader,</span><br><span class="line">    DvmDex* pDvmDex)</span><br><span class="line">&#123;</span><br><span class="line">    Thread* self = dvmThreadSelf();</span><br><span class="line">    ClassObject* clazz; // 类加载的最终形式</span><br><span class="line">    bool profilerNotified = false;</span><br><span class="line">    /* 判断目标类是否有类加载器，对于系统类，虚拟机将从默认的启动路径实现其加载工作</span><br><span class="line">    对于用户类，虚拟机一般情况下使用默认的类加载器实现类加载工作 */</span><br><span class="line">    if (loader != NULL) &#123;</span><br><span class="line">        LOGVV(&quot;#### findClassNoInit(%s,%p,%p)&quot;, descriptor, loader,</span><br><span class="line">            pDvmDex-&gt;pDexFile);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">        /* 根据目标类的描述符从hash表(系统已加载类)里查找是否已经有该Class的信息，如果已经加载，则返回</span><br><span class="line">    其ClassObject对象，否则，对目标类进行加载*/</span><br><span class="line">    clazz = dvmLookupClass(descriptor, loader, true);</span><br><span class="line">    if (clazz == NULL) &#123;</span><br><span class="line">        const DexClassDef* pClassDef;</span><br><span class="line"></span><br><span class="line">        dvmMethodTraceClassPrepBegin();</span><br><span class="line">        profilerNotified = true;</span><br><span class="line"></span><br><span class="line">#if LOG_CLASS_LOADING</span><br><span class="line">        u8 startTime = dvmGetThreadCpuTimeNsec();</span><br><span class="line">#endif</span><br><span class="line">        /* 判断是否存在DvmDex结构体对象，如果存在，则表示目标类为一个用户类，将从一个解析的Dex文件</span><br><span class="line">        中进行加载，对于一个解析过的Dex文件，是一定存在一个DvmDex结构体对象的，故pDvmDex一定不为空</span><br><span class="line">        若为空，则表示目标类是一个系统类，虚拟机将调用searchBootPathForClass函数从启动路径下查找并</span><br><span class="line">        加载目标类 */</span><br><span class="line">        if (pDvmDex == NULL) &#123;</span><br><span class="line">            assert(loader == NULL);     /* shouldn&apos;t be here otherwise */</span><br><span class="line">            /* 从BOOTCLASSPATH里那一堆jar包文件中，看看哪个jar包声明了目标类返回的是一个打开了的代</span><br><span class="line">            表odex文件的DvmDex对象 */</span><br><span class="line">            pDvmDex = searchBootPathForClass(descriptor, &amp;pClassDef);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 查找目标类的类定义资源</span><br><span class="line">            pClassDef = dexFindClass(pDvmDex-&gt;pDexFile, descriptor);</span><br><span class="line">        &#125;</span><br><span class="line">	...</span><br><span class="line">        /* 当获得了加载目标类所需的各项资源，主函数将调用loadClassFromDex函数对目标类进行加载 */</span><br><span class="line">        clazz = loadClassFromDex(pDvmDex, pClassDef, loader);</span><br><span class="line">        if (dvmCheckException(self)) &#123;</span><br><span class="line">            /* class was found but had issues */</span><br><span class="line">            if (clazz != NULL) &#123;</span><br><span class="line">                dvmFreeClassInnards(clazz);</span><br><span class="line">                dvmReleaseTrackedAlloc((Object*) clazz, NULL);</span><br><span class="line">            &#125;</span><br><span class="line">            goto bail;</span><br><span class="line">        &#125;</span><br><span class="line">        /* 将目前使用的类锁住，防止其他进程更改 */</span><br><span class="line">        dvmLockObject(self, (Object*) clazz);</span><br><span class="line">        clazz-&gt;initThreadId = self-&gt;threadId;</span><br><span class="line">        </span><br><span class="line">        assert(clazz-&gt;classLoader == loader);</span><br><span class="line">        if (!dvmAddClassToHash(clazz)) &#123; // class对象加到Hash表里</span><br><span class="line">	        clazz-&gt;initThreadId = 0;</span><br><span class="line">            dvmUnlockObject(self, (Object*) clazz);</span><br><span class="line"></span><br><span class="line">            /* Let the GC free the class. */</span><br><span class="line">            dvmFreeClassInnards(clazz);</span><br><span class="line">            dvmReleaseTrackedAlloc((Object*) clazz, NULL);</span><br><span class="line">            /* 从已加载的类的系统Hash表中重新得到类 */</span><br><span class="line">            clazz = dvmLookupClass(descriptor, loader, true);</span><br><span class="line">            assert(clazz != NULL);</span><br><span class="line">            goto got_class;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">                /*</span><br><span class="line">         * 准备开始连接类，对clazz进行一些处理：</span><br><span class="line">         * 1.解析ClassObject对象的基类信息，和它实现了那些接口</span><br><span class="line">         * 2.校验：比如父类是final的，那么就不应该有它的派生类等</span><br><span class="line">         * 此函数调用成功后，clazz的状态将是CLASS_RESOLVED或CLASS_VERIFIED</span><br><span class="line">         */</span><br><span class="line">        if (!dvmLinkClass(clazz)) &#123;</span><br><span class="line">            assert(dvmCheckException(self));</span><br><span class="line">            /* Make note of the error and clean up the class. */</span><br><span class="line">            removeClassFromHash(clazz);</span><br><span class="line">            clazz-&gt;status = CLASS_ERROR;</span><br><span class="line">            dvmFreeClassInnards(clazz);</span><br><span class="line">            /* Let any waiters know. */</span><br><span class="line">            clazz-&gt;initThreadId = 0;</span><br><span class="line">            dvmObjectNotifyAll(self, (Object*) clazz);</span><br><span class="line">            dvmUnlockObject(self, (Object*) clazz);</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        /* 将类的状态增加到全局变量中去 */</span><br><span class="line">        gDvm.numLoadedClasses++;</span><br><span class="line">        gDvm.numDeclaredMethods +=</span><br><span class="line">            clazz-&gt;virtualMethodCount + clazz-&gt;directMethodCount;</span><br><span class="line">        gDvm.numDeclaredInstFields += clazz-&gt;ifieldCount;</span><br><span class="line">        gDvm.numDeclaredStaticFields += clazz-&gt;sfieldCount;</span><br><span class="line">        ...</span><br><span class="line">    /* check some invariants */</span><br><span class="line">    assert(dvmIsClassLinked(clazz));</span><br><span class="line">    assert(gDvm.classJavaLangClass != NULL);</span><br><span class="line">    assert(clazz-&gt;clazz == gDvm.classJavaLangClass);</span><br><span class="line">    assert(dvmIsClassObject(clazz));</span><br><span class="line">    assert(clazz == gDvm.classJavaLangObject || clazz-&gt;super != NULL);</span><br><span class="line">    if (!dvmIsInterfaceClass(clazz)) &#123;</span><br><span class="line">        //ALOGI(&quot;class=%s vtableCount=%d, virtualMeth=%d&quot;,</span><br><span class="line">        //    clazz-&gt;descriptor, clazz-&gt;vtableCount,</span><br><span class="line">        //    clazz-&gt;virtualMethodCount);</span><br><span class="line">        assert(clazz-&gt;vtableCount &gt;= clazz-&gt;virtualMethodCount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">bail:</span><br><span class="line">    if (profilerNotified)</span><br><span class="line">        dvmMethodTraceClassPrepEnd();</span><br><span class="line">    assert(clazz != NULL || dvmCheckException(self));</span><br><span class="line">    return clazz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用dvmLookupClass函数判断本类是否已经被加载，</p>
<p>如果已经加载：直接返回，</p>
<p>如果没加载未加载：判断能否找到Dex文件，能找到调用<code>dexFindClass</code>在指定Dex文件中根据类的描述符查找相关类（用户类）；找不到调用<code>searchBootPathForClass</code>从系统启动基本路径中查找并加载目标类（系统类）。调用loadClassFromDex函数实现加载类达到可运行状态。调用dvmAddClassToHash实现将新加载的类添加到哈希表中方便在此查找。</p>
<p>loadClassFromDex 函数将调用<code>loadClassFromDex0</code>函数完成对该类的加载工作，返回值为一个<code>ClassObject</code>结构体对象。</p>
<img src="/2018/03/17/Dalvik加载dex/9.png">
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line">static ClassObject* loadClassFromDex0(DvmDex* pDvmDex,</span><br><span class="line">    const DexClassDef* pClassDef, const DexClassDataHeader* pHeader,</span><br><span class="line">    const u1* pEncodedData, Object* classLoader)</span><br><span class="line">&#123;</span><br><span class="line">    ClassObject* newClass = NULL; // 目标类的类实例对象</span><br><span class="line">    const DexFile* pDexFile;      // 用于存储目标Dex文件所对应的DexFile数据结构实例对象</span><br><span class="line">    const char* descriptor;       // 用于存储目标类的描述符</span><br><span class="line">    int i;</span><br><span class="line">    // 获取相应的类信息</span><br><span class="line">    pDexFile = pDvmDex-&gt;pDexFile;</span><br><span class="line">    descriptor = dexGetClassDescriptor(pDexFile, pClassDef);</span><br><span class="line">    ...</span><br><span class="line">    // 为即将生成的类对象实例申请内存空间</span><br><span class="line">    assert(descriptor != NULL);</span><br><span class="line">    // 判断是不是java.lang.Class类，此类已经初始化过了</span><br><span class="line">    if (classLoader == NULL &amp;&amp;</span><br><span class="line">        strcmp(descriptor, &quot;Ljava/lang/Class;&quot;) == 0) &#123;</span><br><span class="line">        assert(gDvm.classJavaLangClass != NULL);</span><br><span class="line">        newClass = gDvm.classJavaLangClass;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 取得对象实例大小并在内存中申请相应内存</span><br><span class="line">        size_t size = classObjectSize(pHeader-&gt;staticFieldsSize);</span><br><span class="line">        newClass = (ClassObject*) dvmMalloc(size, ALLOC_NON_MOVING);</span><br><span class="line">    &#125;</span><br><span class="line">    if (newClass == NULL)</span><br><span class="line">        return NULL;</span><br><span class="line"></span><br><span class="line">    // 对新的类对象实例进行初始化</span><br><span class="line">    DVM_OBJECT_INIT(newClass, gDvm.classJavaLangClass);</span><br><span class="line">    dvmSetClassSerialNumber(newClass);</span><br><span class="line">    newClass-&gt;descriptor = descriptor;</span><br><span class="line">    assert(newClass-&gt;descriptorAlloc == NULL);</span><br><span class="line">    SET_CLASS_FLAG(newClass, pClassDef-&gt;accessFlags);</span><br><span class="line">    // 设定字段对象</span><br><span class="line">    dvmSetFieldObject((Object *)newClass,</span><br><span class="line">                      OFFSETOF_MEMBER(ClassObject, classLoader),</span><br><span class="line">                      (Object *)classLoader);</span><br><span class="line">    // 设定类的相关指针</span><br><span class="line">    newClass-&gt;pDvmDex = pDvmDex;</span><br><span class="line">    newClass-&gt;primitiveType = PRIM_NOT;</span><br><span class="line">    newClass-&gt;status = CLASS_IDX;</span><br><span class="line">    // 将这个类的父类的索引加入到类对象的指针区域</span><br><span class="line">    assert(sizeof(u4) == sizeof(ClassObject*)); /* 32-bit check */</span><br><span class="line">    newClass-&gt;super = (ClassObject*) pClassDef-&gt;superclassIdx;</span><br><span class="line"></span><br><span class="line">    const DexTypeList* pInterfacesList;</span><br><span class="line">    // 得到接口列表</span><br><span class="line">    pInterfacesList = dexGetInterfacesList(pDexFile, pClassDef);</span><br><span class="line">    if (pInterfacesList != NULL) &#123;</span><br><span class="line">        newClass-&gt;interfaceCount = pInterfacesList-&gt;size;</span><br><span class="line">        newClass-&gt;interfaces = (ClassObject**) dvmLinearAlloc(classLoader,</span><br><span class="line">                newClass-&gt;interfaceCount * sizeof(ClassObject*));</span><br><span class="line">        // newClass实现了哪些接口类，此处也先以接口类的index存储，后续放到dvmLinkClass来解析</span><br><span class="line">        for (i = 0; i &lt; newClass-&gt;interfaceCount; i++) &#123;</span><br><span class="line">            const DexTypeItem* pType = dexGetTypeItem(pInterfacesList, i);</span><br><span class="line">            newClass-&gt;interfaces[i] = (ClassObject*)(u4) pType-&gt;typeIdx;</span><br><span class="line">        &#125;</span><br><span class="line">        dvmLinearReadOnly(classLoader, newClass-&gt;interfaces);</span><br><span class="line">    &#125;</span><br><span class="line">    // 对字段进行加载，首先加载静态字段</span><br><span class="line">    if (pHeader-&gt;staticFieldsSize != 0) &#123;</span><br><span class="line">        /* static fields stay on system heap; field data isn&apos;t &quot;write once&quot; */</span><br><span class="line">        int count = (int) pHeader-&gt;staticFieldsSize;</span><br><span class="line">        u4 lastIndex = 0;</span><br><span class="line">        DexField field;</span><br><span class="line">        // 取得字段数</span><br><span class="line">        newClass-&gt;sfieldCount = count;</span><br><span class="line">        // 逐一加载字段</span><br><span class="line">        for (i = 0; i &lt; count; i++) &#123;</span><br><span class="line">            dexReadClassDataField(&amp;pEncodedData, &amp;field, &amp;lastIndex);</span><br><span class="line">            // 解析newClass定义的静态成员信息</span><br><span class="line">            loadSFieldFromDex(newClass, &amp;field, &amp;newClass-&gt;sfields[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 加载实例字段</span><br><span class="line">    if (pHeader-&gt;instanceFieldsSize != 0) &#123;</span><br><span class="line">        int count = (int) pHeader-&gt;instanceFieldsSize;</span><br><span class="line">        u4 lastIndex = 0;</span><br><span class="line">        DexField field;</span><br><span class="line">        // 取得字段数</span><br><span class="line">        newClass-&gt;ifieldCount = count;</span><br><span class="line">        newClass-&gt;ifields = (InstField*) dvmLinearAlloc(classLoader,</span><br><span class="line">                count * sizeof(InstField));</span><br><span class="line">        // 逐一加载字段</span><br><span class="line">        for (i = 0; i &lt; count; i++) &#123;</span><br><span class="line">            dexReadClassDataField(&amp;pEncodedData, &amp;field, &amp;lastIndex);</span><br><span class="line">            loadIFieldFromDex(newClass, &amp;field, &amp;newClass-&gt;ifields[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        dvmLinearReadOnly(classLoader, newClass-&gt;ifields);</span><br><span class="line">    &#125;</span><br><span class="line">    // 对类方法进行加载</span><br><span class="line">    if (pHeader-&gt;directMethodsSize != 0) &#123;</span><br><span class="line">        int count = (int) pHeader-&gt;directMethodsSize;</span><br><span class="line">        u4 lastIndex = 0;</span><br><span class="line">        DexMethod method;</span><br><span class="line">        // 取得方法数目</span><br><span class="line">        newClass-&gt;directMethodCount = count;</span><br><span class="line">        newClass-&gt;directMethods = (Method*) dvmLinearAlloc(classLoader,</span><br><span class="line">                count * sizeof(Method));</span><br><span class="line">        // 逐一加载方法</span><br><span class="line">        for (i = 0; i &lt; count; i++) &#123;</span><br><span class="line">            dexReadClassDataMethod(&amp;pEncodedData, &amp;method, &amp;lastIndex);</span><br><span class="line">            loadMethodFromDex(newClass, &amp;method, &amp;newClass-&gt;directMethods[i]);</span><br><span class="line">            if (classMapData != NULL) &#123;</span><br><span class="line">                const RegisterMap* pMap = dvmRegisterMapGetNext(&amp;classMapData);</span><br><span class="line">                if (dvmRegisterMapGetFormat(pMap) != kRegMapFormatNone) &#123;</span><br><span class="line">                    newClass-&gt;directMethods[i].registerMap = pMap;</span><br><span class="line">                    /* TODO: add rigorous checks */</span><br><span class="line">                    assert((newClass-&gt;directMethods[i].registersSize+7) / 8 ==</span><br><span class="line">                        newClass-&gt;directMethods[i].registerMap-&gt;regWidth);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dvmLinearReadOnly(classLoader, newClass-&gt;directMethods);</span><br><span class="line">    &#125;</span><br><span class="line">    // 加载虚方法</span><br><span class="line">    if (pHeader-&gt;virtualMethodsSize != 0) &#123;</span><br><span class="line">        int count = (int) pHeader-&gt;virtualMethodsSize;</span><br><span class="line">        u4 lastIndex = 0;</span><br><span class="line">        DexMethod method;</span><br><span class="line">        // 取得虚方法数目</span><br><span class="line">        newClass-&gt;virtualMethodCount = count;</span><br><span class="line">        newClass-&gt;virtualMethods = (Method*) dvmLinearAlloc(classLoader,</span><br><span class="line">                count * sizeof(Method));</span><br><span class="line">        // 逐一处理方法</span><br><span class="line">        for (i = 0; i &lt; count; i++) &#123;</span><br><span class="line">            dexReadClassDataMethod(&amp;pEncodedData, &amp;method, &amp;lastIndex);</span><br><span class="line">            loadMethodFromDex(newClass, &amp;method, &amp;newClass-&gt;virtualMethods[i]);</span><br><span class="line">            if (classMapData != NULL) &#123;</span><br><span class="line">                const RegisterMap* pMap = dvmRegisterMapGetNext(&amp;classMapData);</span><br><span class="line">                if (dvmRegisterMapGetFormat(pMap) != kRegMapFormatNone) &#123;</span><br><span class="line">                    newClass-&gt;virtualMethods[i].registerMap = pMap;</span><br><span class="line">                    /* TODO: add rigorous checks */</span><br><span class="line">                    assert((newClass-&gt;virtualMethods[i].registersSize+7) / 8 ==</span><br><span class="line">                        newClass-&gt;virtualMethods[i].registerMap-&gt;regWidth);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dvmLinearReadOnly(classLoader, newClass-&gt;virtualMethods);</span><br><span class="line">    &#125;</span><br><span class="line">    // 保存源文件信息</span><br><span class="line">    newClass-&gt;sourceFile = dexGetSourceFile(pDexFile, pClassDef);</span><br><span class="line"></span><br><span class="line">    /* caller must call dvmReleaseTrackedAlloc */</span><br><span class="line">    return newClass; // 返回类对象</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>依次完成：</p>
<p>1.在内存中为类对象申请存储空间；</p>
<p>2.设置字段信息；</p>
<p>3.为超类建立索引；</p>
<p>4.加载类接口；</p>
<p>5.加载类字段；</p>
<p>6.加载类方法，并将以上数据封装成一个ClassObject结构体对象并返回。</p>
<h2 id="0x04-最后"><a href="#0x04-最后" class="headerlink" title="0x04 最后"></a>0x04 最后</h2><p>每次分析源码都能看到一些新的东西，常看常新，上面的知识点对于脱早期壳非常重要</p>
<p>比如熟悉Dalvik加载dex的机制，那么就能知道可以在何处下断，然后在内存中dump下dex文件</p>
<p>熟悉类的运行时解析机制，就可以对付某些讲类指令抽空的壳</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Android/" rel="tag"># Android</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/03/17/apktool漏洞利用分析/" rel="next" title="apktool漏洞利用分析">
                <i class="fa fa-chevron-left"></i> apktool漏洞利用分析
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/03/17/2013plaidctf-ropasaurusrex/" rel="prev" title="2013plaidctf-ropasaurusrex">
                2013plaidctf-ropasaurusrex <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpg"
                alt="Mask" />
            
              <p class="site-author-name" itemprop="name">Mask</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">29</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">9</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#0x00-前言"><span class="nav-number">1.</span> <span class="nav-text">0x00 前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0x01-DexClassLoader和PathClassLoader"><span class="nav-number">2.</span> <span class="nav-text">0x01 DexClassLoader和PathClassLoader</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0x02-Davlik加载Dex文件"><span class="nav-number">3.</span> <span class="nav-text">0x02 Davlik加载Dex文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0x03-运行时解析"><span class="nav-number">4.</span> <span class="nav-text">0x03 运行时解析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0x04-最后"><span class="nav-number">5.</span> <span class="nav-text">0x04 最后</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Mask</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
